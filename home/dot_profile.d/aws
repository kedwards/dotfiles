#!/usr/bin/bash
# AWS Profile & SSM Management
# DO NOT EDIT THIS FILE - Generated by chezmoi template

# Logging functions
log_info() {
  echo "[INFO] $*" >&2
}

log_error() {
  echo "[ERROR] $*" >&2
}

# Switches AWS profiles and sets the active profile in the environment.
# Arguments:
#   $1 - The profile name or option (-c, -u, -x).
#   $2 - The AWS reg2ion (optional).
aws-profile_switcher2() {
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    cat <<EOF
Usage: aws-profile_switcher [OPTIONS] [PROFILE] [REGION]

Manages AWS profiles and SSO authentication.

OPTIONS:
    -h, --help      Show this help message
    -c PROFILE      Login via SSO to console and set profile active
    -u              Unset active profile
    -x              Logout of SSO and unset profile
    
PARAMETERS:
    PROFILE         Name of AWS profile
    REGION          AWS region (optional)

EXAMPLES:
    aws-profile_switcher my-profile us-west-2
    aws-profile_switcher -c my-profile
    aws-profile_switcher -u
    aws-profile_switcher -x
EOF
    return 0
  elif [[ "$1" == "-u" || "$1" == "-x" ]]; then
    log_info "Unsetting AWS profile"
    unset ENV AWS_PROFILE AWS_ACCOUNT 2>/dev/null || true
    export ENV AWS_PROFILE AWS_ACCOUNT
    
    if command -v assume >/dev/null 2>&1; then
      assume --unset 2>/dev/null || log_error "Could not unset assume session"
    fi
    
    if [[ "$1" == "-x" ]]; then
      log_info "Logging out of AWS SSO"
      if command -v granted >/dev/null 2>&1; then
        granted sso-tokens clear --all 2>/dev/null || log_error "Could not clear SSO tokens"
      fi
    fi
  else
    if ! command -v assume >/dev/null 2>&1; then
      log_error "'assume' command not found. Please install granted."
      return 1
    fi
    
    local cmd="assume"
    for arg in "$@"; do
      cmd="$cmd $(printf '%q' "$arg")"
    done
    
    log_info "Executing: $cmd"
    
    if eval "$cmd"; then
      export ENV="$AWS_PROFILE"
      aws-whoami2 >/dev/null 2>&1 || log_error "Could not retrieve AWS identity"
      return 0
    else
      log_error "Failed to assume AWS profile"
      return 1
    fi
  fi
}

# Prints the current AWS account ID and alias.
# Returns:
#   0 if the profile is set, 1 otherwise.
aws-whoami2() {
  if [[ -z "${AWS_PROFILE:-}" ]]; then
    echo "No AWS profile is set"
    return 1
  fi

  log_info "Getting AWS identity for profile '$AWS_PROFILE'"

  local account_alias
  account_alias=$(aws iam list-account-aliases --query "AccountAliases[0]" --output text 2>/dev/null) || {
    log_error "Could not retrieve account alias"
    return 1
  }

  if [[ -n "$account_alias" && "$account_alias" != "None" ]]; then
    echo "AWS Account: $account_alias"
    
    local user_id account arn
    if read -r user_id account arn <<<"$(aws sts get-caller-identity --query "[UserId,Account,Arn]" --output text 2>/dev/null)"; then
      echo "User: $user_id"
      echo "Account: $account"
      echo "Arn: $arn"
      export AWS_ACCOUNT="$account"
    else
      log_error "Could not retrieve caller identity"
      return 1
    fi
  else
    log_error "No account alias found"
    return 1
  fi
}

# Auto-completion setup for bash
profile_switcher_completer() {
  mapfile -t COMPREPLY < <(aws configure list-profiles | grep --color=never "^${COMP_WORDS[COMP_CWORD]}")
}
complete -F profile_switcher_completer aws-profile_switcher2 p2

# Connects to an instance via SSM.
# Arguments:
#   $1 - The instance name or ID, or -config for config file.
#   $2 - The host (optional for manual port forwarding).
#   $3 - The port (optional for manual port forwarding).
#   $4 - The local port (optional for manual port forwarding).
aws-ssm_connect2() {
  use_config=false

  if [[ "$1" =~ "-h" ]] || [[ "$1" = "--help" ]]; then
    cat <<EOF
Connect to an instance via SSM
Usage:
  aws-ssm_connect [-config | <intance-name|instance-id> ] [ <host>:localhost ] [ <port>:5432 ] [ <local_port>:\$port ] }

Connect Examples:
  aws-ssm_connect               : search for an instance to connect to
  aws-ssm_connect instance-name : connect to an instance named instance-name
  aws-ssm_connect i-XXXXXXXXXX  : connect to an instance by instance-id

Port Forwarding Examples:
  aws-ssm_connect -config : use config file (~/.reach.conf) to set up port forwarding
  aws-ssm_connect my-instance rch-cf-rds-engine.rch 5432 9999 : forwarding local port 9999 to remote port 5432

Config File Format (~/.reach.conf):
  Required fields: port, profile, region
  Optional fields: name, local_port, host, url
  
  Defaults:
    - local_port defaults to port if not specified
    - host defaults to 'localhost' if not specified
    - If name is not specified, you'll be prompted to select from running instances
    - If url is specified, browser will open automatically; otherwise no browser opens
  
  Minimal config example:
    [my-db-connection]
    port = 5432
    profile = my-profile
    region = my-aws-region
EOF
  elif [[ -n "${AWS_PROFILE:-}" ]] || [[ "$1" = "-config" ]]; then
    if ! command -v aws >/dev/null 2>&1; then
      log_error "AWS CLI not found. Please install the AWS CLI."
      return 1
    fi
    if [ "$1" = "-config" ]; then
      shift
      use_config=true
    fi

    # Handle config-based port forwarding
    if [[ "$use_config" = "true" ]]; then
      local CONFIG_FILE="${SSMF_CONF:-$HOME/.ssmf.cfg}"

      if [[ ! -f "$CONFIG_FILE" ]]; then
        log_error "Config file not found: $CONFIG_FILE"
        echo "Please create $CONFIG_FILE with your connection configurations."
        return 1
      fi

      if [[ ! -r "$CONFIG_FILE" ]]; then
        log_error "Cannot read config file: $CONFIG_FILE"
        return 1
      fi

      # Get the list of available connections
      mapfile -t connections < <(grep -oP '(?<=^\[).*?(?=\])' "$CONFIG_FILE")

      if [[ ${#connections[@]} -eq 0 ]]; then
        log_error "No connections found in $CONFIG_FILE"
        return 1
      fi

      # Use fzf if available, otherwise fall back to select menu
      if command -v fzf >/dev/null 2>&1; then
        connection=$(printf '%s\n' "${connections[@]}" | fzf --prompt="Select connection: " --height=~50% --reverse --header="Available Connections")
        
        if [ -z "$connection" ]; then
          log_info "No connection selected. Cancelled."
          return 0
        fi
      else
        PS3='Select connection, or 0 to exit: '
        select connection in "${connections[@]}"; do
          if [[ $REPLY == "0" ]]; then
            return
          elif [[ -z $connection ]]; then
            printf '"%s" is not a valid choice\\n' "$REPLY" >&2
          else
            break
          fi
        done
      fi

      # Extract connection details
      # Clear any variables from previous config to prevent carryover
      unset name port local_port url profile region host
      
      local config_vars
      config_vars=$(awk -F ' = ' -v section="[$connection]" '
        $0 == section {found=1; next} 
        found && NF==2 {print $1 "=" $2} 
        found && /^\[.*\]/ {exit}
      ' "$CONFIG_FILE")

      eval "$config_vars" # Convert extracted key-value pairs into variables

      # Validate required parameters
      if [[ -z "$port" || -z "$profile" || -z "$region" ]]; then
        log_error "Invalid configuration for $connection. Missing required parameters."
        echo "Required: port, profile, region"
        return 1
      fi

      # Set defaults
      local_port=${local_port:-$port}  # Default local_port to port if not specified
      host=${host:-localhost}          # Default host to localhost if not specified
      
      # Switch to the profile specified in config if different from current
      if [[ "$AWS_PROFILE" != "$profile" ]]; then
        log_info "Switching to profile: $profile (region: $region)"
        aws-profile_switcher "$profile" -r "$region"
      fi

      # Get instance ID from name, or search if name not provided
      local instanceId
      local instanceName=""
      if [[ -z "$name" ]]; then
        log_info "No instance name specified, searching for running instances..."
        aws-get_all_running_instances ""

      if [ -z "$instance_array" ]; then
          log_error "No running instances found"
          return 1
        elif [ "${#instance_array[@]}" -eq 1 ]; then
          instanceName=$(echo "${instance_array[0]}" | sed 's/\"//g' | cut -d' ' -f1)
          instanceId=$(echo "${instance_array[0]}" | sed 's/\"//g' | cut -d' ' -f2)
          log_info "Found single instance: $instanceName ($instanceId)"
        else
          # Use fzf if available, otherwise fall back to select menu
          if command -v fzf >/dev/null 2>&1; then
            local selected
            selected=$(printf '%s\n' "${instance_array[@]}" | fzf --prompt="Select instance for port forwarding: " --height=~50% --reverse --header="Running EC2 Instances (${AWS_PROFILE:-none})")
            
            if [ -z "$selected" ]; then
              log_info "No instance selected. Cancelled."
              return 0
            fi
            
            instanceName=$(echo "${selected}" | sed 's/\"//g' | cut -d' ' -f1)
            instanceId=$(echo "${selected}" | sed 's/\"//g' | cut -d' ' -f2)
            log_info "Selected instance: $instanceName ($instanceId)"
          else
            PS3='Select instance for port forwarding, or 0 to exit: '
            select instance_choice in "${instance_array[@]}"; do
              if [[ $REPLY == "0" ]]; then
                return
              elif [[ -z $instance_choice ]]; then
                printf '"%s" is not a valid choice\\n' "$REPLY" >&2
              else
                break
              fi
            done
            instanceName=$(echo "${instance_choice}" | sed 's/\"//g' | cut -d' ' -f1)
            instanceId=$(echo "${instance_choice}" | sed 's/\"//g' | cut -d' ' -f2)
            log_info "Selected instance: $instanceName ($instanceId)"
          fi
        fi
      else
        instanceName="$name"
        instanceId=$(aws ec2 describe-instances \
          --filter "Name=tag:Name,Values=$name" \
          --query "Reservations[0].Instances[?State.Name == 'running'].InstanceId[]" \
          --output text)

        if [[ -z "$instanceId" || "$instanceId" == "None" ]]; then
          log_error "No running instance found with name: $name"
          return 1
        fi
        log_info "Using instance: $instanceName ($instanceId)"
      fi

      log_info "Starting SSM port forwarding session via $instanceName to $host:$port (local port: $local_port)"
      aws ssm start-session --target "$instanceId" \
        --document-name AWS-StartPortForwardingSessionToRemoteHost \
        --parameters "{\"host\":[\"${host:-localhost}\"],\"portNumber\":[\"$port\"], \"localPortNumber\":[\"$local_port\"]}" &
      
      local ssm_pid=$!
      log_info "SSM session started with PID: $ssm_pid (kill with: kill $ssm_pid)"

      # Open the URL in browser only if explicitly provided in config
      if [[ -n "${url:-}" ]]; then
        sleep 2  # Give the session time to start
        xdg-open "$url" 2>/dev/null || log_error "Could not open URL: $url"
      fi

      return 0
    fi

    local instanceIdentifier=$1
    local instanceId=""

    if [[ -z "$instanceIdentifier" ]]; then
      # No argument provided - show menu of all instances
      aws-get_all_running_instances2 ""

      if [ -z "$instance_array" ]; then
        echo "No running instances found"
        return
      elif [ "${#instance_array[@]}" -eq 1 ]; then
        instanceName=$(echo "${instance_array[0]}" | sed 's/\"//g' | cut -d' ' -f1)
        instanceId=$(echo "${instance_array[0]}" | sed 's/\"//g' | cut -d' ' -f2)
        log_info "Found single instance: $instanceName ($instanceId)"
      else
        # Use fzf if available, otherwise fall back to select menu
        if command -v fzf >/dev/null 2>&1; then
          local selected
          selected=$(printf '%s\n' "${instance_array[@]}" | fzf --prompt="Select instance to connect to: " --height=~50% --reverse --header="Running EC2 Instances (${AWS_PROFILE:-none})")
          
          if [ -z "$selected" ]; then
            log_info "No instance selected. Cancelled."
            return 0
          fi
          
          instanceName=$(echo "${selected}" | sed 's/\"//g' | cut -d' ' -f1)
          instanceId=$(echo "${selected}" | sed 's/\"//g' | cut -d' ' -f2)
          log_info "Selected instance: $instanceName ($instanceId)"
        else
          PS3='Select instance to connect to, or 0 to exit: '
          select instanceIdentifier in "${instance_array[@]}"; do
            if [[ $REPLY == "0" ]]; then
              return
            elif [[ -z $instanceIdentifier ]]; then
              printf '"%s" is not a valid choice\\n' "$REPLY" >&2
            else
              break
            fi
          done
          instanceName=$(echo "${instanceIdentifier}" | sed 's/\"//g' | cut -d' ' -f1)
          instanceId=$(echo "${instanceIdentifier}" | sed 's/\"//g' | cut -d' ' -f2)
          log_info "Selected instance: $instanceName ($instanceId)"
        fi
      fi
    elif [[ "${instanceIdentifier:0:2}" == "i-" ]]; then
      # Instance ID provided - use directly
      instanceId=$instanceIdentifier
      log_info "Using instance ID: $instanceId"
    else
      # Instance name provided - look it up
      instanceId=$(aws ec2 describe-instances \
        --filters "Name=tag:Name,Values=$instanceIdentifier" "Name=instance-state-name,Values=running" \
        --query "Reservations[0].Instances[0].InstanceId" \
        --output text)
      
      if [[ -z "$instanceId" || "$instanceId" == "None" ]]; then
        log_error "No running instance found with name: $instanceIdentifier"
        return 1
      fi
      log_info "Using instance: $instanceIdentifier ($instanceId)"
    fi

    aws ssm start-session --target "$instanceId"
  else
    echo 'No profile is set'
    return 1
  fi
}

# Queries AWS SSM for a list of running instances.
# Arguments:
#   $1 - The instance name to search for (optional).
aws-get_all_running_instances2() {
  local instance_name="$1"
  local query_search

  if [[ -n "$instance_name" ]]; then
    query_search=" && Tags[?Key=='Name' && contains(Value, '$instance_name')]].[Tags[?Key=='Name']"
  else
    query_search="].[Tags[?Key=='Name']"
  fi

  local query="Reservations[].Instances[?State.Name == 'running'${query_search} | [0].Value, InstanceId][]"
  mapfile -t instance_array < <(aws ec2 describe-instances --query "$query" --output json | jq -r 'sort_by(.[]) | .[] | join(" ")')
}

# Gets instance ID(s) based on the provided identifier(s).
# Arguments:
#   $1 - The instance identifier(s) (name or ID).
aws-get_instance2() {
  mapfile -t instanceArray <<< "$1"

  local instances=""
  for instanceIdentifier in "${instanceArray[@]}"; do
    if [[ "${instanceIdentifier:0:2}" == "i-" ]]; then
      instance_id=$(aws ec2 describe-instances --instance-ids "$instanceIdentifier" --query "Reservations[].Instances[?State.Name == 'running'].InstanceId[]" --output text)
    else
      instance_id=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$instanceIdentifier" --query "Reservations[].Instances[?State.Name == 'running'].InstanceId[]" --output text)
    fi
    instances+="$instance_id "
  done

  instances=$(echo "$instances" | xargs)  # Trim excess whitespace
  echo "$instances"
}

# Gets AWS VPN Client Endpoint configuration.
# Arguments are optional
# logged in environment will be default.
# Arguments:
#   $1 - The AWS profile 
#   $2 - The AWS region
aws-get_vpn_client_endpoint2() {
  local profile=${1:-$AWS_PROFILE}
  local region=${2:-$AWS_REGION}

  if [[ "$1" == "-h" || "$1" == "--help" || -z "$profile" ]]; then
    cat <<EOF
Usage: aws-get_vpn_client_endpoint [<profile>] [<region>]
Get client VPN endpoint configuration.
Use arguments to provide profile/region or use the logged-in profile/region.
Parameters:
  profile:  AWS profile
  region:   AWS region
EOF
    return 1
  else
    if [[ "$profile" == "$AWS_PROFILE" ]]; then
      aws ec2 export-client-vpn-client-configuration \
        --client-vpn-endpoint-id "$(aws ec2 describe-client-vpn-endpoints \
          --query "ClientVpnEndpoints[0].ClientVpnEndpointId" --output text)" \
        --output text | tee "${profile}_client_vpn.ovpn"
    else
      aws-profile_switcher2 "$profile" -r "$region" --exec -- "aws ec2 export-client-vpn-client-configuration \
        --client-vpn-endpoint-id $(aws-profile_switcher2 "$profile" -r "$region" --exec -- aws ec2 describe-client-vpn-endpoints \
        --query 'ClientVpnEndpoints[0].ClientVpnEndpointId' --output text) \
        --output text | tee \"${profile}_client_vpn.ovpn\""
    fi

    # Remove 'verify-x509-name' line from .ovpn file
    # === BASH SED COMMAND ===
    sed -i '/verify-x509-name/d' "${profile}_client_vpn.ovpn"
  fi
  return 0
}

# List all AWS profiles in configuration
aws-list_aws_profiles2() {
  # out=$(grep "^\[.*\]" "$HOME/.aws/config" | sed 's/\[//g;s/\]//g' | cut -d ' ' -f 2)
  out=$(grep 'profile' "$HOME/.aws/config" | awk '{ print substr($2,1,length($2)-1) }')
  if [ -n "$1" ]; then
    local -n input_ref=$1
    input_ref=$out
  else
    echo $out
  fi
}

aws-run_against_environement2() {
  local command="$1"
  local profile="$2"
  local region="${3:-us-east-1}"

  if [[ "$1" == "-h" || "$1" == "--help" || -z "$command" ]]; then
    cat <<EOF
Usage: aws-run_against_profile <command> [<environment list>] [<region>]
Run a command against an aws environment
Parameters:
  command: The command to run
  environment: The environment to run the command against (or omit for interactive selection)
Example:
  aws-run_against_all_profiles "aws ec2 describe-vpcs --query 'Vpcs[*][CidrBlock, OwnerId]' --output table" "fail:us-east-1 how:us-east-1"
  aws-run_against_all_profiles "aws rds describe-db-instances --query 'DBInstances[*].[DBInstanceIdentifier,Engine,EngineVersion,DBClusterIdentifier]' --output table" ninja:us-east-1
  aws-run_against_all_profiles "for user in $(aws iam list-users --output text | awk "{ print $NF }"); do aws iam list-access-keys --user $user --output text; done;" "red:us-east-1 coffee:us-east-1 maison:us-east-1"
  aws-run_against_all_profiles "aws s3 ls"  # Interactive multi-select with fzf
EOF
# python -c "import boto3, sys; env, region = sys.argv[1], sys.argv[2]; bucket_name = f'rch-cf-ipfinder-{env}-{region}'; b = boto3.resource('s3', region_name=region).Bucket(bucket_name); b.object_versions.delete(); b.delete()" lol us-east-1
    return 1
  fi

  # If no profile provided, use fzf for interactive multi-selection
  if [[ -z "$profile" ]]; then
    if ! command -v fzf >/dev/null 2>&1; then
      log_error "fzf is required for interactive selection but not found"
      echo "Please provide profiles manually or install fzf"
      return 1
    fi
    
    # Get all profiles (convert space-separated to array)
    local profiles_output
    profiles_output=$(aws-list_aws_profiles2)
    read -ra all_profiles <<< "$profiles_output"
    
    if [[ ${#all_profiles[@]} -eq 0 ]]; then
      log_error "No AWS profiles found in configuration"
      return 1
    fi
    
    # Use fzf for multi-selection of profiles
    local selected
    selected=$(printf '%s\n' "${all_profiles[@]}" | fzf --multi --prompt="Select profiles (TAB to multi-select, ENTER to confirm): " --height=~50% --reverse --header="AWS Profiles")
    
    if [[ -z "$selected" ]]; then
      log_info "No profiles selected. Cancelled."
      return 0
    fi
    
    # Common AWS regions
    local -a regions=("us-east-1" "us-east-2" "us-west-1" "us-west-2" "eu-west-1" "eu-central-1" "ap-southeast-1" "ap-southeast-2" "ap-northeast-1")
    
    # Build profile list - ask for region per profile
    profile=""
    while IFS= read -r prof; do
      [[ -z "$prof" ]] && continue
      log_info "Select region(s) for profile: $prof (TAB for multi-select)"
      local selected_regions
      # Allow multi-select for regions
      selected_regions=$(printf '%s\n' "${regions[@]}" | fzf --multi --prompt="Select region(s) for $prof (TAB to multi-select): " --height=~50% --reverse --header="AWS Regions")
      
      if [[ -z "$selected_regions" ]]; then
        log_info "No region selected for $prof, using default: $region"
        selected_regions="$region"
      fi
      
      # Add each selected region as a separate profile:region pair
      while IFS= read -r selected_region; do
        [[ -z "$selected_region" ]] && continue
        # Trim whitespace
        selected_region=$(echo "$selected_region" | xargs)
        log_info "Adding to profile string: ${prof}:${selected_region}"
        profile="${profile}${prof}:${selected_region} "
      done <<< "$selected_regions"
    done <<< "$selected"
    profile=$(echo "$profile" | xargs)  # Trim whitespace
    log_info "Profile string built: $profile"
  fi

  if [ "$profile" == "all" ]; then
    for prof in $(aws-list_aws_profiles2);
    do
      aws-profile_switcher2 "$prof" -r "$region"
      echo "$AWS_PROFILE:$AWS_REGION"
      eval "$command"
    done
  else
    # Convert space-separated pairs to array for proper iteration
    read -ra profile_pairs <<< "$profile"
    
    for pair in "${profile_pairs[@]}"; do
      [[ -z "$pair" ]] && continue
      
      log_info "Processing pair: '$pair'"
      env=$(echo "$pair" | cut -d':' -f1)
      local pair_region=$(echo "$pair" | cut -d':' -f2)
      pair_region=${pair_region:-us-east-1}
      log_info "Parsed - env: '$env', region: '$pair_region'"

      aws-profile_switcher2 "$env" -r "$pair_region"
      echo $AWS_PROFILE:$AWS_REGION
      local cmd_to_run=$(echo "$command" | sed "s/#ENV/$AWS_PROFILE/g; s/#REGION/$AWS_REGION/g")

      # this is for running aws_ssm_command (x)
      # it parses the command for instance names
      # and replace them with the instance id
      IFS=', ' read -r -a co <<< "$cmd_to_run"
      if [ ${co[0]} = 'x' -o ${co[0]} = 'aws_ssm_command' ]; then
        inst=$(aws-get_instance2 ${co[1]})
        cmd_to_run=${cmd_to_run/${co[1]}/$inst}
      fi

      eval $cmd_to_run
    done
  fi
}


# Executes a command on instance(s) via SSM
aws-ssm_execute2() {
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    cat <<EOF
Usage:
  aws-ssm_execute <command> [<instance> <instance> ..]  : execute a command on instance(s) via SSM
  aws-ssm_execute <command>                             : interactive fzf multi-select (no instances provided)
  aws-ssm_execute <instance> --file=<file>              : execute a command via file input on instance(s) via SSM

Examples:
  aws-ssm_execute 'ls /opt/configuration/engine/' i-XXXXXXXXXXXXXXXXX i-XXXXXXXXXXXXXXXXX
  aws-ssm_execute 'ls /opt/configuration/engine/'  # Interactive multi-select
  aws-ssm_execute --file=myCommandsFile.sh i-XXXXXXXXXXXXXXXXX i-XXXXXXXXXXXXXXXXX
EOF
  return 1
  fi

  command=$1
  shift
  instance_ids=$@
  
  # If no instance IDs provided, use fzf for interactive multi-selection
  if [[ -z "$instance_ids" ]]; then
    if ! command -v fzf >/dev/null 2>&1; then
      echo "Error: fzf is required for interactive selection but not found"
      echo "Please provide instance IDs manually or install fzf"
      return 1
    fi
    
    # Get all running instances
    aws-get_all_running_instances2 ""
    
    if [ -z "$instance_array" ] || [ "${#instance_array[@]}" -eq 0 ]; then
      echo "No running instances found"
      return 1
    fi
    
    # Use fzf for multi-selection
    local selected
    selected=$(printf '%s\n' "${instance_array[@]}" | fzf --multi --prompt="Select instances (TAB to multi-select, ENTER to confirm): " --height=~50% --reverse --header="Running EC2 Instances (${AWS_PROFILE:-none})")
    
    if [ -z "$selected" ]; then
      echo "No instances selected. Cancelled."
      return 0
    fi
    
    # Extract instance IDs from selections
    instance_ids=$(echo "$selected" | sed 's/\"//g' | awk '{print $NF}' | xargs)
    
    if [ -z "$instance_ids" ]; then
      echo "No valid instance IDs extracted. Cancelled."
      return 1
    fi
    
    echo "Selected instances: $instance_ids"
  fi

  for instance in $instance_ids; do
    status=$(aws ssm describe-instance-information \
      --instance-information-filter-list key=InstanceIds,valueSet=$instance \
      --query 'InstanceInformationList[].{id:InstanceId,status:PingStatus}' \
      --output text 2>&1)

    if [ $? -ne 0 ]; then
      echo $status
      instance_ids=${instance_ids/$instance}
      continue
    fi

    if ! echo "$status" | grep -q "Online"; then
      echo instance $instance is not running SSM agent
      instance_ids=${instance_ids/$instance}
    fi
  done

  if [ -z "$instance_ids" ]; then
    echo No instances available to run commands
    exit 2
  fi

  if [ "$command" == "--file"  ]; then
    if [ -z "$3" ]; then
      echo "aws_ssm_execute <instance> --file=<file>  : execute a command via file input on an instance via SSM"
      return 1
    else
      tmpfile=$3
    fi
  else
    tmpfile=$(mktemp /tmp/ssm-script.XXXXXX)

    cat <<EOF > $tmpfile
{
  "Parameters": {
    "commands": [
      "#!/bin/bash",
      "$command"
    ],
    "executionTimeout": ["600"]
  }
}
EOF

    command_id=$(aws ssm send-command \
      --instance-ids $instance_ids \
      --document-name "AWS-RunShellScript" \
      --cli-input-json file://$tmpfile \
      --query 'Command.{CommandId:CommandId}' \
      --timeout-seconds 600 \
      --output text 2>&1)

    res=$?
    if [ $res -ne 0 ]; then
      echo "ERROR invoking command: $command_id"
      exit $res
    fi

    echo "Command launched with id $command_id"

    n_instances=$( echo $INSTANCE_IDS | wc -w )
    while true; do
      finished=0
      for instance in $instance_ids; do
        status=$(aws ssm get-command-invocation \
          --command-id $command_id \
          --instance-id $instance \
          --query Status \
          --output text | tr '[A-Z]' '[a-z]')

        now=$(date +%Y-%m-%dT%H:%M:%S%z)
        echo $now $instance: $status
        case $status in
          pending|inprogress|delayed) : ;;
          *) finished=$(( finished + 1 )) ;;
        esac
      done
      [ $finished -ge $n_instances ] && break
      sleep 2
    done

    for instance in $instance_ids; do
      status=$(aws ssm get-command-invocation --command-id $command_id --instance-id $instance --query Status --output text)
      out_result=$(aws ssm get-command-invocation --command-id $command_id --instance-id $instance --query StandardOutputContent --output text)
      err_result=$(aws ssm get-command-invocation --command-id $command_id --instance-id $instance --query StandardErrorContent --output text)

      echo "------------------------------------"
      echo "RESULTS FROM $instance (STATUS $status):"

      if [ -n "$out_result" ]; then
        echo "STDOUT:"
        echo "$out_result"
        echo "------------------------------------"
      fi

      if [ -n "$err_result" ]; then
          echo "STDERR:"
          echo "$err_result"
          echo "------------------------------------"
      fi

      if [ -z "$out_result" -a -z "$err_result" ]; then
          echo NO OUTPUT RETURNED
      fi
    done

    rm $tmpfile
  fi
}

# List all active SSM sessions
aws-ssm_list2() {
  local current_profile="${AWS_PROFILE:-none}"
  echo "Active SSM sessions (Current profile: $current_profile):"
  
  ps aux | grep "session-manager-plugin" | grep -v grep | while read -r line; do
    local pid=$(echo "$line" | awk '{print $2}')
    # Extract target from either --target flag (aws CLI) or TargetId JSON (session-manager-plugin)
    local target=$(echo "$line" | grep -oP '\-\-target \K[^ ]+')
    if [[ -z "$target" ]]; then
      target=$(sed -n 's/.*TargetId":"\([^"]*\)".*/\1/p' <<< "$line" | head -n1)
    fi

    # Determine session type and details
    local session_type="Interactive Shell"
    local port="" host=""
    if echo "$line" | grep -q "StartPortForwardingSessionToRemoteHost"; then
      port=$(sed -n 's/.*localPortNumber":\["\([0-9]*\)".*/\1/p' <<< "$line" | head -n1)
      host=$(sed -n 's/.*"host":\["\([^"]*\)".*/\1/p' <<< "$line" | head -n1)
      [[ -z "$host" ]] && host="localhost"
      session_type="Port: ${port:-?} -> ${host}"
    elif echo "$line" | grep -q "StartPortForwardingSession"; then
      port=$(sed -n 's/.*localPortNumber":\["\([0-9]*\)".*/\1/p' <<< "$line" | head -n1)
      host=$(sed -n 's/.*DestinationHost":"\([^"]*\)".*/\1/p' <<< "$line" | head -n1)
      [[ -z "$host" ]] && host="localhost"
      session_type="Port: ${port:-?} -> ${host}"
    fi

    # Try to get instance name from AWS (resolves when in correct profile)
    local instance_name=""
    if [[ -n "$target" ]]; then
      instance_name=$(aws ec2 describe-instances --instance-ids "$target" \
        --query "Reservations[0].Instances[0].Tags[?Key=='Name'].Value" \
        --output text 2>/dev/null || echo "")
    fi
    
    if [[ -n "$instance_name" && "$instance_name" != "None" ]]; then
      echo "  PID: $pid | $session_type | Instance: $instance_name (${target:-unknown})"
    else
      echo "  PID: $pid | $session_type | Instance: ${target:-unknown}"
    fi
  done
  
  echo ""
  echo "Tip: Switch to the correct AWS profile to see instance names"
  echo "Kill a session: kill <PID>  or use 'ssmk' for interactive selection"
}

# Kill SSM session(s) interactively
aws-ssm_kill2() {
  # Get list of all SSM sessions
  mapfile -t sessions < <(ps aux | grep "session-manager-plugin" | grep -v grep)
  
  if [ ${#sessions[@]} -eq 0 ]; then
    echo "No active SSM sessions found."
    return 0
  fi
  
  # Build array of formatted session info
  local -a session_list
  local -a pid_list
  for line in "${sessions[@]}"; do
    local pid=$(echo "$line" | awk '{print $2}')
    # Extract target from either --target flag (aws CLI) or TargetId JSON (session-manager-plugin)
    local target=$(echo "$line" | grep -oP '\-\-target \K[^ ]+')
    if [[ -z "$target" ]]; then
      target=$(sed -n 's/.*TargetId":"\([^"]*\)".*/\1/p' <<< "$line" | head -n1)
    fi
    
    # Check if it's port forwarding or interactive
    if echo "$line" | grep -q "StartPortForwardingSessionToRemoteHost"; then
      local port=$(sed -n 's/.*localPortNumber":\["\([0-9]*\)".*/\1/p' <<< "$line" | head -n1)
      local host=$(sed -n 's/.*"host":\["\([^"]*\)".*/\1/p' <<< "$line" | head -n1)
      [[ -z "$host" ]] && host="localhost"
      local session_type="Port: ${port:-?} -> ${host}"
    elif echo "$line" | grep -q "StartPortForwardingSession"; then
      local port=$(sed -n 's/.*localPortNumber":\["\([0-9]*\)".*/\1/p' <<< "$line" | head -n1)
      local host=$(sed -n 's/.*DestinationHost":"\([^"]*\)".*/\1/p' <<< "$line" | head -n1)
      [[ -z "$host" ]] && host="localhost"
      local session_type="Port: ${port:-?} -> ${host}"
    else
      local session_type="Interactive Shell"
    fi
    
    # Try to get instance name
    local instance_name=""
    if [[ -n "$target" ]]; then
      instance_name=$(aws ec2 describe-instances --instance-ids "$target" \
        --query "Reservations[0].Instances[0].Tags[?Key=='Name'].Value" \
        --output text 2>/dev/null || echo "")
    fi
    
    if [[ -n "$instance_name" && "$instance_name" != "None" ]]; then
      session_list+=("PID: $pid | $session_type | Instance: $instance_name (${target:-unknown})")
    else
      session_list+=("PID: $pid | $session_type | Instance: ${target:-unknown}")
    fi
    pid_list+=("$pid")
  done
  
  # Use fzf if available, otherwise use select
  if command -v fzf >/dev/null 2>&1; then
    local selected
    selected=$(printf '%s\n' "${session_list[@]}" | fzf --multi --prompt="Select session(s) to kill (TAB to multi-select, Ctrl-C to cancel): " --height=~50% --reverse --header="Active SSM Sessions (${AWS_PROFILE:-none})")
    
    if [ -z "$selected" ]; then
      echo "No session selected. Cancelled."
      return 0
    fi
    
    # Extract PIDs from all selections and kill them
    while IFS= read -r selection; do
      [[ -z "$selection" ]] && continue
      local selected_pid=$(echo "$selection" | grep -oP 'PID: \K[0-9]+')
      
      if [ -n "$selected_pid" ]; then
        echo "Killing SSM session with PID: $selected_pid"
        kill "$selected_pid" 2>/dev/null && log_info "Session $selected_pid terminated successfully" || log_error "Failed to kill session $selected_pid"
      fi
    done <<< "$selected"
  else
    # Fallback to select menu
    echo "Active SSM port forwarding sessions:"
    PS3='Select session to kill (or 0 to cancel): '
    select session in "${session_list[@]}"; do
      if [[ $REPLY == "0" ]]; then
        echo "Cancelled."
        return 0
      elif [[ -z $session ]]; then
        printf '"%s" is not a valid choice\n' "$REPLY" >&2
      else
        # Get the corresponding PID
        local idx=$((REPLY - 1))
        local selected_pid="${pid_list[$idx]}"
        echo "Killing SSM session with PID: $selected_pid"
        kill "$selected_pid" 2>/dev/null && log_info "Session $selected_pid terminated successfully" || log_error "Failed to kill session $selected_pid"
        break
      fi
    done
  fi
}

alias p2='aws-profile_switcher2'
alias aws2-whoami='aws-whoami2'
alias ssm2='aws-ssm_connect2'
alias ssmf2='aws-ssm_connect2 -config'
alias ssmx2='aws-ssm_execute2'
alias ssml2='aws-ssm_list2'
alias ssmk2='aws-ssm_kill2'
alias rae2='aws-run_against_environement2'
